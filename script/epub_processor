#!/usr/bin/env ruby
# frozen_string_literal: true

# Script for EPUB Pipeline class using Fulcrum processors

require 'optparse'
require 'ostruct'
require 'os'

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require_relative File.join(root_dir, "lib", "logger")

script_logger = UMPTG::Logger.create(logger_fp: STDOUT)

# Process the script parameters.
options = OpenStruct.new
options.manifest_file = nil
options.normalize = false
options.filter_list = []
options.process = :none
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-f filter] [-m manifest_file] [-n] [-p migrator|none|resource_processor|reviewer] epub_file [epub_file...]"
  opts.on('-f', '--filter filter', 'Filter name') do |filter|
    options.filter_list << filter.to_sym
  end
  opts.on('-m', '--manifest manifest_file', 'Resource manifest file') do |manifest_file|
    options.manifest_file = manifest_file
  end
  opts.on('-n', '--normalize', 'Use which link as resource') do |flag|
    options.normalize = true
  end
  opts.on('-p', '--process migrator|none|resource_processor|reviewer', 'EPUB Processor (default is reviewer)') do |flag|
    options.process = flag.to_sym
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    script_logger.info(opts)
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  script_logger.info(option_parser.help)
  return
end

# Process the command line parameters.
epub_file_list = ARGV

require 'nokogiri'
require 'mime/types'

require_relative File.join(root_dir, "lib", "epub")
require_relative File.join(root_dir, "lib", "fulcrum", "manifest")
require_relative File.join(root_dir, "lib", "fulcrum", "filter")
require_relative File.join(root_dir, "lib", "fulcrum", "metadata")
require_relative File.join(root_dir, "lib", "fulcrum", "resources")

# Verify process and filter arguments
if options.filter_list.empty?
  if options.process == :none
    script_logger.error("must specify either -p process or -f filter.")
    exit(1)
  end
  unless [ :migrator, :resource_processor, :reviewer].include?(options.process)
    script_logger.error("invalid process, #{options.process}")
    exit(1)
  end
else
  unless options.process == :none
    script_logger.error("must not specify both -p process or -f filter.")
    exit(1)
  end
end

# Collect EPUB Processor arguments
epub_args = {}

# Determine if a Fulcrum resource manifest is to be used.
manifest = nil
unless options.manifest_file.nil?
  manifest_file = File.expand_path(options.manifest_file)
  unless File.file?(manifest_file)
    script_logger.error("#{manifest_file} is not a file.")
    exit 1
  end
  manifest = UMPTG::Fulcrum::Manifest::Document.new(
        csv_file: manifest_file
      )
  epub_args[:manifest] = manifest
end

# Configure the EPUB Processor
case options.process
when :migrator
  # EPUB Migration
  epub_processor = UMPTG::EPUB::Migrator(
                    epub_args
          )
when :resource_processor
  # EPUB Resource processing
  epub_processor = UMPTG::Fulcrum::ResourceProcessor(
                          epub_args
                      )
when :reviewer
  # EPUB Review
  epub_processor = UMPTG::EPUB::Reviewer(
                          epub_args
                      )
else
  # EPUB customized processing. Use the specified filters
  ops = {}
  options.filter_list.each {|f| ops[f] = true }

  # Use the manifest if specified.
  xhtml_processor = manifest.nil? ? nil : \
        UMPTG::Fulcrum::Resources::XHTML::Processor(
              name: "FulcrumResourceProcessor",
              manifest: manifest,
              options: ops
            )

  # No processor specified. Just filters specified
  epub_processor = UMPTG::EPUB::Processor(
            xhtml_processor: xhtml_processor,
            options: ops
      )
end

# Process each EPUB
epub_file_list.each do |epub_file|
  unless File.file?(epub_file)
    script_logger.error("invalid EPUB file #{epub_file}")
    exit 1
  end
  script_logger.info("processing EPUB file #{File.basename(epub_file)}")

  logger_file =  File.join(
            File.dirname(epub_file),
            File.basename(epub_file, ".*") + "_" + File.basename(__FILE__) + ".log"
            )
  epub_processor.logger = UMPTG::Logger.create(logger_file: logger_file)

  epub = UMPTG::EPUB(epub_path: epub_file)
  epub_processor.logger.info("processing EPUB file #{File.basename(epub_file)}")
  epub_processor.logger.info("Time: #{Time.now}")
  epub_processor.logger.info("version #{epub.rendition.version}")
  identifiers = epub.rendition.metadata.dc.elements.identifier.collect {|d| d.text}
  epub_processor.logger.info("identifiers: #{identifiers.join(',')}")
  epub_processor.logger.info()

  entry_actions = epub_processor.run(
            epub,
            {
                normalize: options.normalize
            }
         )

  epub_processor.process_entry_action_results(
          epub: epub,
          entry_actions: entry_actions,
          normalize: options.normalize
        )

  if options.normalize and epub.modified
    new_epub_file = File.join(
          File.dirname(epub_file),
          File.basename(epub_file, ".*") + "_" + File.basename(__FILE__) + File.extname(epub_file)
          )
    epub.save(epub_file: new_epub_file)
    script_logger.info("Saved File #{new_epub_file}.")
  end
end
