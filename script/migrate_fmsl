#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'ostruct'

# Process the script parameters.
options = OpenStruct.new
options.output_csv = false
options.output_xml = false
options.skip_resources_check = false
options.include_notes = false
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-c] [-n] [-r] [-x] fmsl_file [fmsl_file...]"
  opts.on('-c', '--csv', 'Save CSV file') do |output_csv|
    options.output_csv = true
  end
  opts.on('-n', '--notes', 'Include Validation Notes column in CSV') do |include_notes|
    options.include_notes = true
  end
  opts.on('-r', '--resources', '') do |skip_resources_check|
    options.skip_resources_check = true
  end
  opts.on('-x', '--xml', 'Save XML instance file') do |output_xml|
    options.output_xml = true
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    puts opts
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  puts option_parser.help
  return
end

fmsl_file_list = ARGV

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require 'csv'

require_relative File.join(root_dir, "lib", "fmsl")
require_relative File.join(root_dir, "lib", "manifest")

NOTES_COLUMN = "Validation Notes"

fmsl_file_list.each do |fmsl_file|
  fmsl_file = File.expand_path(fmsl_file)
  if !File.file?(fmsl_file)
    puts "Error: invalid FMSL file #{fmsl_file}"
    next
  end

  fmsl_body = UMPTG::FMSL.load(:fmsl_file => fmsl_file)
  manifest_csv = UMPTG::FMSL.to_manifest(:fmsl_body => fmsl_body)

  collection = UMPTG::Manifest::Validation::Collection.new
  manifest_name = File.join(File.basename(fmsl_file, ".*") + "_fulcrum")
  manifest = UMPTG::Manifest::Document.new(
        :name => manifest_name,
        :csv_body => manifest_csv.to_s
      )
  collection.add_manifest(manifest)

  if options.output_xml
    output_file = File.join(File.dirname(fmsl_file), File.basename(fmsl_file, ".*") + ".xml")
    File.write(output_file, collection.xml_markup)
  end

  error_count = 0
  resource_errors = {}

  unless options.skip_resources_check
    manifest_csv.each do |row|
      resource_name = row['File Name']
      next if resource_name == UMPTG::Manifest.BLANK_ROW_FILE_NAME

      resource_file = File.join(File.dirname(fmsl_file), resource_name)
      unless File.file?(resource_file)
        error_count += 1
        #puts "Error: resource file #{resource_name} does not exist."
        resource_errors[resource_name] = [ "Error: resource file does not exist." ]
      end
    end
  end

  error_list = UMPTG::Manifest::Validation::CollectionSchema.validate(:xml_markup => collection.xml_markup)
  puts "Error count: #{error_count + error_list.count}"

  if error_count > 0
    resource_errors.each do |key,val|
      puts "#{key}: #{val.first}"
    end
  end

  if error_list.count > 0
    vtree = UMPTG::Manifest::ValidationResult::VTreeBuilder.build(collection.xml_markup)
    puts "vtree is nil" if vtree.nil?

    error_list.each do |error|
      level = error.error? ? "error" : error.warning? ? "warning" : error.fatal? ? "fatal" : "none"
      puts "error line: #{error.line}"
      property = vtree.property(error.line) unless vtree.nil?
      puts "\t#{property}" unless property.nil?
      puts "\t#{property.resource_name}" unless property.nil?

      resource_name = property.resource_name unless property.nil?
      unless resource_name.nil?
        if resource_errors[resource_name].nil?
          resource_errors[resource_name] = [ error ]
        else
          resource_errors[resource_name] << error
        end
      end
    end
  end

  # Save the Fulcrum manifest file.
  if options.output_csv
    fulcrum_headers = options.include_notes ? \
              [ NOTES_COLUMN ] + manifest_csv.headers : \
              manifest_csv.headers
    fulcrum_file = File.join(File.dirname(fmsl_file), manifest_name + ".csv")
    CSV.open(
            fulcrum_file,
            "w",
            :write_headers=> true,
            :force_quotes => true,
            :headers => fulcrum_headers
          ) do |csv|
      manifest_csv.each do |row|
        resource_name = row['File Name']
        error_list = resource_errors[resource_name]
        if error_list.nil?
          error_value = "None"
        else
          error_value = error_list.join("\n")
        end

        r = options.include_notes ? \
                { NOTES_COLUMN => error_value } : \
                {}
        row.each do |key,val|
          r[key] = val
        end
        csv << r
      end
    end
    puts "Saved CSV file #{fulcrum_file}."
  end
end
