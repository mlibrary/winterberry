#!/usr/bin/env ruby
# frozen_string_literal: true

# Script inputs a list of monograph directories
# and inserts the specified CC license.

require 'optparse'
require 'ostruct'
require 'os'

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require_relative File.join(root_dir, "lib", "logger")

script_logger = UMPTG::Logger.create(logger_fp: STDOUT)

# Process the script parameters.
options = OpenStruct.new
options.license = :cc_by_nc
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-l license] monograph_dir [<monograph_dir>..]"
  opts.on('-l', '--license [license]', 'License') do |license|
    options.license = license.to_sym
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    script_logger.info(opts)
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  script_logger.info(option_parser.help)
  exit 0
end
monograph_dir_list = ARGV

require 'csv'
#require 'origami'

require_relative File.join(root_dir, 'lib', 'review')
require_relative File.join(root_dir, 'lib', 'fulcrum')

# Determine is license file is available
bname = options.license.to_s.gsub('_', '-')
license_file = Dir.glob(File.join(root_dir, "lib", "license", "cc_badges", bname + ".xhtml")).first
if license_file.nil?
  script_logger.error("CC badge #{options.license} is not found.")
  exit(1)
end
script_logger.info("CC badge #{options.license} found.")

license_doc = Nokogiri::XML(File.read(license_file))
license_body_node = license_doc.xpath("//*[local-name()='body']").first
if license_body_node.nil?
  script_logger.error("unable to find license body element.")
  exit(1)
end

img_file_list = []
license_body_node.xpath(".//*[local-name()='img']").each do |img_node|
  src = img_node['src']
  img_file = File.expand_path(src, File.dirname(license_file))
  unless File.exist?(img_file)
    script_logger.error("image file #{img_file} not found in license file #{license_file}")
    next
  end
  img_file_list << img_file
end

epub_updater = UMPTG::Review::EPUBUpdater.new(
      logger: script_logger
      )

monograph_dir_list.each do |monograph_dir|
  monograph_dir = File.expand_path(monograph_dir)
  unless File.directory?(monograph_dir)
    script_logger.error("directory \"#{File.basename(monograph_dir)}\" does not exist.")
    next
  end
  script_logger.info("processing directory \"#{File.basename(monograph_dir)}\"")

  # Load the monograph manifest.
  manifest_file = File.join(monograph_dir, "manifest.csv")
  unless File.file?(manifest_file)
    script_logger.error("directory \"#{File.basename(manifest_file)}\" does not exist.")
    next
  end
  manifest = UMPTG::Fulcrum::Manifest::Document.new(
                csv_file: manifest_file
              )

  # Get the EPUB path.
  epub_row = manifest.representative_row(kind: "epub")
  if epub_row.nil?
    script_logger.error("no EPUB row found for monograph #{monograph_dir}")
    next
  end
  epub_file = File.join(monograph_dir, epub_row['file_name'])
  epub = UMPTG::EPUB::Archive.new(epub_file: epub_file)

  license_frag = license_body_node.dup

=begin
  funder_display = manifest.monograph_row['funder_display']
  funder_display_node = license_frag.xpath(".//*[@id='funder_description']").first
  if funder_display_node.nil?
    script_logger.warn("funder display node not found.")
  else
    funder_display_node.content = funder_display
    script_logger.info("funder display inserted.")
  end
=end

  oa_isbn = manifest.isbn['open access']
  oa_isbn = manifest.isbn['oa ebook'] if oa_isbn.nil?
  isbn_oa_node = license_frag.xpath(".//*[@id='isbn_open_access']").first
  if isbn_oa_node.nil?
    script_logger.warn("funder description node not found.")
  else
    isbn_oa_node.content = "ISBN: #{oa_isbn} (open access)"
    script_logger.info("OA ISBN inserted.")
  end

  img_file_list.each do |img_file|
    img_file = File.expand_path(img_file)
    script_logger.info("adding manifest item #{img_file}")

    epub_updater.add_item(
        epub: epub,
        item_file: img_file
        )
  end

  # Process the epub and generate the image information.
  epub_reviewer = UMPTG::Review::EPUBReviewer.new(
        epub: epub,
        logger: script_logger
      )
  epub_reviewer.review(
        review_options: { add_license: true },
        license_fragment: license_frag,
        normalize: true
      )

  if epub.modified
    epub_reviewer = UMPTG::Review::EPUBReviewer.new(
          epub: epub,
          logger: script_logger
        )

    epub_reviewer.review(
          review_options: { fix_img_ref: true },
          normalize: true
        )

    # EPUB updated. Save it to a new file.
    new_epub_file = File.join(File.dirname(epub_file), File.basename(epub_file, ".*") + "_cc_license" + File.extname(epub_file))
    script_logger.info("EPUB updated. Writing new EPUB file #{File.basename(new_epub_file)}")
    epub.save(epub_file: new_epub_file)
  else
    # No EPUB updates.
    script_logger.info("no updates for EPUB file #{File.basename(epub_file)}")
  end

  STDOUT.flush
end
