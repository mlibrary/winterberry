#!/usr/bin/env ruby
# frozen_string_literal: true

# Script operates on a monograph directory found the Fulcrum
# shared drive.
#
# It generates a resource map file (if one doesn't exist) and
# if the -fmsl option is specified and a monograph epub/FMSL
# exist, then it will update the existing resource FMSL
# properties with values found in the epub.

require 'optparse'
require 'ostruct'

# Process the script parameters.
options = OpenStruct.new
options.update_fmsl = true
options.use_map = true
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-map] [-nofmsl] <monograph_dir> [<monograph_dir>...]"
  opts.on('-map', '--map', 'Overwrite existing resource map file.') do |da|
    options.use_map = false
  end
  opts.on('-nofmsl', '--nofmsl', 'Do not update FMSL.') do |da|
    options.update_fmsl = false
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    puts opts
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  puts option_parser.help
  return
end

monograph_dir_list = ARGV
update_fmsl = options.update_fmsl
use_map = options.use_map

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require 'fileutils'

require_relative File.join(root_dir, "lib", "monograph")
require_relative File.join(root_dir, "lib", "epubprocessor")
require_relative File.join(root_dir, "lib", "csvfile_new")

resource_map_file_headers = [ "File Name", "Resource Name" ]

imgprocessor = nil

monograph_dir_list.each do |monograph_dir|
  puts "*** Processing Monograph directory #{monograph_dir} ***"

  # Find the monograph resources directory.
  resources_dir = File.join(monograph_dir, "resources")
  if !File.directory?(resources_dir)
    puts "Error: no resources directory found for ISBN #{isbm}."
    next
  end

  # Find the EPUB.
  epub_file_list = Dir.glob(File.join(monograph_dir, "*.epub"))
  if epub_file_list.count == 0
    puts "Error: no EPUB found for ISBN #{isbn}."
    next
  end
  epub_file = epub_file_list.first
  puts "Warning: multiple EPUBs for ISBN #{isbn}. Using #{File.basename(epub_file)}." \
        if epub_file_list.count > 1
  puts "Using EPUB #{File.basename(epub_file)}." if epub_file_list.count == 1

  # Find the monograph processing directory.
  processing_dir = File.join(monograph_dir, "resource_processing")

  # Determine if the resource map file exists. If not,
  # then one needs to be generated.
  resource_map_file = File.join(processing_dir, "resource_map.csv")
  resource_map_exists = File.exists?(resource_map_file) && use_map

  if resource_map_exists
    puts "INFO: using existing resource map file #{File.basename(resource_map_file)}"
  end

  if update_fmsl or !resource_map_exists
    # Either updating the FMSL or the resource map file
    # needs to be generated.

    # Initialize/reset the image processor.
    if imgprocessor.nil?
      imgprocessor = ImgProcessor.new
    else
      imgprocessor.reset
    end

    # Process the epub and generate the image information.
    EpubProcessor.process(
          :epub_file => epub_file,
          :processors => [ imgprocessor ]
        )

    # If a resource map exists, use it. Otherwise,
    # it should be generated and saved.
    resource_map = nil
    if resource_map_exists
      resource_map = CSVFile.read(:csv_path => resource_map_file)
    else
      puts "INFO: generating resource map file #{File.basename(resource_map_file)}."
    end

    # Retrieve the list of resources
    resources = Dir.glob(File.join(resources_dir, "*"))

    # Determine the headers to use for the resource info
    # CSV.
    headers = resource_map_file_headers
    imgprocessor.img_list.first.map.each do |key,value|
      headers << key
    end

    # Build the resource map CSV string.
    resource_info_body = CSV.generate(
              :headers => headers,
              :write_headers => true
          ) do |csv|
      imgprocessor.img_list.each do |row|
        crow = {}

        ref = row.map['src']

        # Using the EPUB file reference, determine the
        # associated resource name. If a resource map
        # exists, then use it for the mapping. Otherwise,
        # attempt to match file basename minus extension
        # with files in the monograph resources directory.
        if resource_map.nil?
          ref_base = File.basename(ref, ".*")
          rname = resources.find { |file| ref_base == File.basename(file, ".*") }
          resource_name = rname.nil? ? File.basename(ref) : File.basename(rname)
        else
          rname = resource_map.find {|row| row['File Name'] == ref }
          resource_name = rname.nil? ? File.basename(ref) : rname['Resource Name']
        end
        puts "INFO:    #{row.name}: mapping reference \"#{ref}\" to resource \"#{resource_name}\"." \
            unless rname.nil?
        puts "Warning: #{row.name}: no resource found for reference \"#{ref}\". Using name \"#{resource_name}\"." \
            if rname.nil?

        # Add the "File Name" and "Resource Name" values.
        crow[resource_map_file_headers[0]] = ref
        crow[resource_map_file_headers[1]] = resource_name

        # Add values for the other columns, which are
        # the object properties (node attribute and
        # added properties).
        row.map.each do |attr,value|
          crow[attr] = value
        end
        csv << crow
      end
    end

    # Create a CSV object from the CSV string.
    begin
      resource_info_csv = CSV.parse(
                resource_info_body,
                :headers => true,
                :return_headers => false)
     #          :header_converters => lambda { |h| h.downcase.gsub(' ', '_') })
     #          :headers => true, :converters => :all,
    rescue Exception => e
      puts e.message
      return nil
    end

    # Insure that the processing directory exists.
    FileUtils.mkdir_p processing_dir

    # Save the resource map CSV file.
    CSV.open(
            resource_map_file,
            "w",
            :write_headers=> true,
            :headers => [ 'File Name', 'Resource Name' ]
            #:headers => resource_map.headers
          ) do |csv|
      resource_info_csv.each do |row|
        csv << [ row['File Name'], row['Resource Name'] ]
        next

        # Debug code that dumps all information.
        new_row = {}
        row.each do |key,value|
          new_row[key] = value
        end
        csv << new_row
      end
    end

    if update_fmsl
      # Update the FMSL.

      # Find the monograph source FMSL.
      fmsl_file_list = Dir.glob(File.join(resources_dir, "#{isbn}_*"))
      if fmsl_file_list.count == 0
        puts "Error: no FMSL found for ISBN #{isbn}."
        next
      end
      fmsl_file = fmsl_file_list.first
      puts "Warning: multiple FMSLs for ISBN #{isbn}. Using #{File.basename(fmsl_file)}." \
            if fmsl_file_list.count > 1
      puts "Using FMSL #{File.basename(fmsl_file)}." if fmsl_file_list.count == 1

      # Read the monograph source FMSL.
      fmsl_csv = CSVFile.read(:csv_path => fmsl_file)
      if fmsl_csv.nil?
        puts "Error: reading FMSL #{File.basename(fmsl_file)}."
        next
      end

      # Update the alt text and caption information in the FMSL.
      fmsl_csv.each do |fmsl_row|
        resource_name = fmsl_row['File Name']
        resource_row = resource_info_csv.find {|row| row['Resource Name'] == resource_name }
        if resource_row.nil?
          puts "Warning: No alt text/caption found for resource \"#{resource_name}\"."
          next
        end

        alt = fmsl_row["Alternative Text"]
        caption = fmsl_row["Caption"]
        epub_alt = resource_row["alt"]
        epub_caption = resource_row["caption"]

        puts "Warning: no alt text found within EPUB for resource \"#{resource_name}\"." \
            if epub_alt.nil? or epub_alt.empty?
        puts "Warning: overwriting FMSL alt text with EPUB alt text for resource \"#{resource_name}\"" \
            if !(alt.nil? or alt.empty?) and !(epub_alt.nil? or epub_alt.empty?)
            #unless (alt.nil? or alt.empty?) and !(epub_alt.nil? or epub_alt.empty?)
        puts "INFO: updating FMSL alt text with EPUB alt text for resource \"#{resource_name}\"" \
            if (alt.nil? or alt.empty?) and !(epub_alt.nil? or epub_alt.empty?)
        fmsl_row["Alternative Text"] = epub_alt unless epub_alt.nil? or epub_alt.empty?

        puts "Warning: no caption found within EPUB for resource \"#{resource_name}\"." \
            if epub_caption.nil? or epub_caption.empty?
        puts "Warning: overwriting FMSL caption with EPUB caption for resource \"#{resource_name}\"" \
            if !(caption.nil? or caption.empty?) and !(epub_caption.nil? or epub_caption.empty?)
        puts "INFO: updating FMSL caption with EPUB caption for resource \"#{resource_name}\"" \
            if (caption.nil? or caption.empty?) and !(epub_caption.nil? or epub_caption.empty?)
        fmsl_row["Caption"] = epub_caption unless epub_caption.nil? or epub_caption.empty?
      end

      # Save the updated FMSL in the resource processing directory.
      new_fmsl_file = File.join(processing_dir, File.basename(fmsl_file))
      CSV.open(
              new_fmsl_file,
              "w",
              :write_headers=> true,
              :headers => fmsl_csv.headers
            ) do |csv|
        fmsl_csv.each do |fmsl_row|
          new_row = {}
          fmsl_row.each do |key,value|
            new_row[key] = value.force_encoding("UTF-8") if value != nil
          end
          csv << new_row
        end
      end
    end
  end
end
