#!/usr/bin/env ruby
# frozen_string_literal: true

# Script operates on a monograph directory found the Fulcrum
# shared drive.
#
# It generates a resource map file (if one doesn't exist) and
# if the -nofmsl option is not specified and a monograph epub/FMSL
# exist, then it will update the existing resource FMSL
# properties with values found in the epub.
# If the -map option is specified, then the resource map
# is generated even if one exists. Otherwise, if one
# exists, then it is used.

require 'optparse'
require 'ostruct'

# Process the script parameters.
options = OpenStruct.new
options.update_fmsl = true
options.use_map = true
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-map] [-nofmsl] <monograph_dir> [<monograph_dir>...]"
  opts.on('-map', '--map', 'Overwrite existing resource map file.') do |da|
    options.use_map = false
  end
  opts.on('-nofmsl', '--nofmsl', 'Do not update FMSL.') do |da|
    options.update_fmsl = false
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    puts opts
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  puts option_parser.help
  return
end

# Process the command line parameters.
monograph_dir_list = ARGV
update_fmsl = options.update_fmsl
use_map = options.use_map

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require 'fileutils'

require_relative File.join(root_dir, "lib", "monograph")
require_relative File.join(root_dir, "lib", "epubprocessor")
require_relative File.join(root_dir, "lib", "csvfile")
require_relative File.join(root_dir, "lib", "resourcemap")

blank_row_file_name = "***row left intentionally blank***"
blank_row_pattern = "^\*\*\*.* intentionally blank[ ]*\*\*\*$"
imgprocessor = nil

# Process all monograph directories specified.
monograph_dir_list.each do |monograph_dir|
  monograph_dir = File.expand_path(monograph_dir)
  puts "*** Processing Monograph directory #{File.basename(monograph_dir)} ***"

  # Find the monograph resources directory.
  resources_dir = File.join(monograph_dir, "resources")
  if !File.directory?(resources_dir)
    puts "Error: no resources directory found for monograph #{monograph_dir}."
    next
  end

  # Find the EPUB.
  epub_file_list = Dir.glob(File.join(monograph_dir, "*.epub"))
  if epub_file_list.count == 0
    puts "Error: no EPUB found for monograph #{monograph_dir}."
    next
  end
  epub_file = epub_file_list.first
  puts "Warning: multiple EPUBs for monograph #{monograph_dir}. Using #{File.basename(epub_file)}." \
        if epub_file_list.count > 1
  puts "Using EPUB #{File.basename(epub_file)}." if epub_file_list.count == 1

  # Find the monograph processing directory.
  processing_dir = File.join(monograph_dir, "resource_processing")

  # Determine if the resource map file exists. If not,
  # then one needs to be generated.
  resource_map_file = File.join(processing_dir, "resource_map.xml")
  resource_map_exists = File.exists?(resource_map_file) && use_map

  if resource_map_exists
    puts "INFO: using existing resource map file #{File.basename(resource_map_file)}"
  end

  if update_fmsl or !resource_map_exists
    # Either updating the FMSL or the resource map file
    # needs to be generated.

    # Initialize/reset the image processor.
    if imgprocessor.nil?
      imgprocessor = ImgProcessor.new
    else
      imgprocessor.reset
    end

    # Process the epub and generate the image information.
    EpubProcessor.process(
          :epub_file => epub_file,
          :processors => [ imgprocessor ]
        )

    # If a resource map exists, use it. Otherwise,
    # it should be generated and saved.
    resource_map = ResourceMap.new
    if resource_map_exists
      resource_map.load(:xml_path => resource_map_file)
    else
      puts "INFO: generating resource map file #{File.basename(resource_map_file)}."
    end

    # Retrieve the list of resources
    resources = Dir.glob(File.join(resources_dir, "*"))

    # Insure that the processing directory exists.
    FileUtils.mkdir_p processing_dir

    # Process image information and generate the resource map.
    imgprocessor.img_list.each do |node|
      reference = node.map['src']

      # Using the EPUB file reference, determine the
      # associated resource name. If a resource map
      # exists, then use it for the mapping. Otherwise,
      # attempt to match file basename minus extension
      # with files in the monograph resources directory.
      if resource_map_exists
        resource_name = resource_map.reference_resource_name(reference)
        notFound = resource_name.empty?
      else
        ref_base = File.basename(reference, ".*")
        rname = resources.find { |file| ref_base == File.basename(file, ".*") }
        resource_name = rname.nil? ? File.basename(reference) : File.basename(rname)
        notFound = rname.nil?
      end
      puts "INFO:    #{node.name}: mapping reference \"#{reference}\" to resource \"#{resource_name}\"." \
          unless notFound
      puts "Warning: #{node.name}: no resource found for reference \"#{reference}\". Using name \"#{resource_name}\"." \
          if notFound

      m = node.map
      m["caption"] = m["caption"].text unless m["caption"].nil?
      resource_map.add_action(
            :reference => reference,
            :resource_name => resource_name,
            :type => "default",
            :resource_properties => m
          )
    end

    # Determine the headers to use for the resource info CSV.
    # May be deprecated.
    headers = []
    imgprocessor.img_list.first.map.each do |key,value|
      headers << key
    end
    resource_map.add_headers(headers)

    # Save the resource map XML file (and CSV for now).
    resource_map.save(resource_map_file) unless resource_map_exists

    if update_fmsl
      # Update the FMSL.

      # Find the monograph source FMSL.
      fmsl_file_list = Dir.glob(File.join(resources_dir, "*.csv"))
      if fmsl_file_list.count == 0
        puts "Error: no FMSL found for monograph #{monograph_dir}."
        next
      end
      fmsl_file = fmsl_file_list.first
      puts "Warning: multiple FMSLs for ISBN #{isbn}. Using #{File.basename(fmsl_file)}." \
            if fmsl_file_list.count > 1
      puts "Using FMSL #{File.basename(fmsl_file)}." if fmsl_file_list.count == 1

      # Read the monograph source FMSL.
      fmsl_csv = CSVFile.read(:csv_path => fmsl_file)
      if fmsl_csv.nil?
        puts "Error: reading FMSL #{File.basename(fmsl_file)}."
        next
      end

      # Update the alt text and caption information in the FMSL.
      fmsl_csv.each do |fmsl_row|
        resource_name = fmsl_row['File Name']

        resource_row = resource_map.resource_properties(resource_name)
        if resource_row.nil?
          puts "Warning: No alt text/caption found for resource \"#{resource_name}\"."
          next
        end

        alt = fmsl_row["Alternative Text"]
        caption = fmsl_row["Caption"]
        epub_alt = resource_row["alt"]
        epub_caption = resource_row["caption"]

        puts "Warning: no alt text found within EPUB for resource \"#{resource_name}\"." \
            if epub_alt.nil? or epub_alt.empty?
        puts "Warning: overwriting FMSL alt text with EPUB alt text for resource \"#{resource_name}\"" \
            if !(alt.nil? or alt.empty?) and !(epub_alt.nil? or epub_alt.empty?) and alt != epub_alt
            #unless (alt.nil? or alt.empty?) and !(epub_alt.nil? or epub_alt.empty?)
        puts "INFO: updating FMSL alt text with EPUB alt text for resource \"#{resource_name}\"" \
            if (alt.nil? or alt.empty?) and !(epub_alt.nil? or epub_alt.empty?)
        fmsl_row["Alternative Text"] = epub_alt unless epub_alt.nil? or epub_alt.empty?

        puts "Warning: no caption found within EPUB for resource \"#{resource_name}\"." \
            if epub_caption.nil? or epub_caption.empty?
        puts "Warning: overwriting FMSL caption with EPUB caption for resource \"#{resource_name}\"" \
            if !(caption.nil? or caption.empty?) and !(epub_caption.nil? or epub_caption.empty?) and caption != epub_caption
        puts "INFO: updating FMSL caption with EPUB caption for resource \"#{resource_name}\"" \
            if (caption.nil? or caption.empty?) and !(epub_caption.nil? or epub_caption.empty?)
        fmsl_row["Caption"] = epub_caption unless epub_caption.nil? or epub_caption.empty?
      end

      # Look for the dreaded blank second line.
      blank_row = fmsl_csv[0]
      #need_blank_row = blank_row['File Name'].downcase != blank_row_file_name
      need_blank_row = blank_row['File Name'].downcase.match?(blank_row_pattern)

      # Save the updated FMSL in the resource processing directory.
      new_fmsl_file = File.join(processing_dir, File.basename(fmsl_file))
      CSV.open(
              new_fmsl_file,
              "w",
              :write_headers=> true,
              :headers => fmsl_csv.headers
            ) do |csv|
        new_row = {}
        if need_blank_row
          # Make sure the blank row exists, otherwise
          # first resource will not be loaded by
          # the importer.
          puts "INFO: no blank row found. Inserting one."
          new_row['File Name'] = blank_row_file_name
          csv << new_row
        end

        fmsl_csv.each do |fmsl_row|
          new_row = {}
          fmsl_row.each do |key,value|
            new_row[key] = value.force_encoding("UTF-8") if value != nil
          end
          csv << new_row
        end
      end
    end
  end
end
