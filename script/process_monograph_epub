#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'ostruct'

# Process the script parameters.
options = OpenStruct.new
#options.publisher_dir = Dir.pwd
options.publisher_dir = "s:/Information\ Management/Fulcrum/UMP"
#options.publisher_dir = "c:/Users/tbelc/Documents/Fulcrum/UMP/"
options.vendor = "default"
options.fulcrum_host = nil
options.default_actions = {
        keywords:  :disable,
        resources: :embed
        }
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-f production|preview|staging] [-p <publisher_dir>] [-v apex|newgen|default] [-r disable|embed|link|none] [-k disable|link|none] <monograph_id> [<monograph_id>..]"
  opts.on('-f', '--fulcrum_host [production|preview|staging]', 'Fulcrum environment') do |fulcrum_host|
    options.fulcrum_host = fulcrum_host
  end
  opts.on('-k', '--keywords [disable|link|none]', 'Default keywords processing action') do |action|
    options.default_actions[:keywords] = action.to_sym
  end
  opts.on('-p', '--publisher_directory [DIRECTORY]', 'Publisher site directory') do |publisher_dir|
    options.publisher_dir = publisher_dir
  end
  opts.on('-r', '--resources [disable|embed|link|none]', 'Default resources processing action') do |action|
    options.default_actions[:resources] = action.to_sym
  end
  opts.on('-v', '--vendor [vendor]', 'Vendor specific markup apex|newgen|default') do |vendor|
    options.vendor = vendor
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    puts opts
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  puts option_parser.help
  return
end

monograph_id_list = ARGV

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

# Verify existence of the source/project root directories.
publisher_dir = File.expand_path(options.publisher_dir)
if !File.exists?(publisher_dir)
  puts "Error: source directory #{publisher_dir} does not exist."
  exit
end

require 'logger'

require_relative File.join(root_dir, 'lib', 'fulcrum')
require_relative File.join(root_dir, 'lib', 'services')

script_logger = Logger.new(STDOUT)
script_logger.formatter = proc do |severity, datetime, progname, msg|
  "#{severity}: #{msg}\n"
end

script_logger.fatal("Error: invalid default keywords action #{options.keywords_default_action}.") \
      unless UMPTG::Fulcrum::EPUBProcessor.DEFAULT_ACTIONS[:keywords].find {|t| t == options.default_actions[:keywords] }
script_logger.fatal("Error: invalid default resources action #{options.resources_default_action}.") \
      unless UMPTG::Fulcrum::EPUBProcessor.DEFAULT_ACTIONS[:resources].find {|t| t == options.default_actions[:resources] }
script_logger.info("Processing keywords #{options.default_actions[:keywords].to_s}") \
      unless options.default_actions[:keywords] == :disable
script_logger.info("Processing resources #{options.default_actions[:resources].to_s}") \
      unless options.default_actions[:resources] == :disable

options.vendor = 'default' if options.vendor.nil? or options.vendor.empty?
script_logger.info("Using #{options.vendor} processor")

# Create the serivce for retrieving the NOID manifest.
service = UMPTG::Services::Heliotrope.new(
                :fulcrum_host => options.fulcrum_host
              )

# Provide the directory path for adding the stylesheet link.
fulcrum_css_name = 'fulcrum_default.css'
fulcrum_css_file = File.join(root_dir, 'lib', 'css', fulcrum_css_name)

monograph_loggers = {}
monograph_id_list.each do |monograph_id|
  # Use the monograph ID to retrieve the NOID from Fulcrum.
  script_logger.info("*" * 10 + " #{monograph_id} " + "*" * 10)

  monograph_noid = service.monograph_noid(identifier: monograph_id)
  if monograph_noid.nil? or monograph_noid.empty?
    script_logger.error("Error: no NOID found for monograph ID #{monograph_id}")
    next
  end

  # Use the monograph NOID to retrieve the monograph manifest from Fulcrum.
  csv_body = service.monograph_export(noid: monograph_noid)
  if csv_body.nil? or csv_body.empty?
    script_logger.error("Error: no manifest found for id #{monograph_id}")
    next
  end

  manifest = UMPTG::Fulcrum::Manifest::Document.new(
                :csv_body => csv_body
              )

  # From the manifest, determine the ebook ISBN without dashes.
  ebook_isbn = manifest.isbn["open access"]
  ebook_isbn = manifest.isbn["ebook"] if ebook_isbn.nil?
  if ebook_isbn.nil?
    script_logger.error("Error: no ebook ISBN found for ID #{monograph_id}.")
    next
  end

  # Find the ebook source folder. First look for a directory
  # using the monograph id. If not found, then look for one
  # using the ISBN.
  monograph_dir_list = Dir.glob(File.join(publisher_dir, monograph_id))
  if monograph_dir_list.count == 0
    script_logger.warn("Warning: ebook source directory using id #{monograph_id} not found. Using ISBN #{ebook_isbn}.")

    ebook_isbn = ebook_isbn.strip.gsub('-', '')
    monograph_dir_list = Dir.glob(File.join(publisher_dir, "#{ebook_isbn}_*"))
    if monograph_dir_list.count == 0
      script_logger.error("Error: ebook source directory not found for id #{monograph_id}.")
      next
    end
  end

  monograph_dir = monograph_dir_list[0]
  script_logger.warn("Multiple ebook source directories found for id #{monograph_id}. Using #{monograph_dir}") \
        if monograph_dir_list.count > 1
  script_logger.info("Using directory #{monograph_dir}") if monograph_dir_list.count == 1

  # Determine the resource_processing directory.
  process_dir = File.join(monograph_dir, "resource_processing")

  # Verify that the resource_processing directory exists.
  if !File.exists?(process_dir) or !File.directory?(process_dir)
    script_logger.error("Error: directory #{File.basename(process_dir)} is not a valid directory.")
    next
  end

  # Create the log file in the resource_processing directory.
  monograph_log_file = File.join(process_dir, File.basename(__FILE__) + ".log")
  monograph_log = File.open(monograph_log_file, File::WRONLY | File::TRUNC | File::CREAT)
  monograph_loggers[monograph_id] = Logger.new(monograph_log)
  monograph_loggers[monograph_id].formatter = proc do |severity, datetime, progname, msg|
    "#{severity}: #{msg}\n"
  end

  monograph_loggers[monograph_id].info("*" * 10 + " #{monograph_id} " + "*" * 10)
  monograph_loggers[monograph_id].info("Using #{options.vendor} processor")

  # Determine if the resources directory exists.
  resources_dir = File.join(monograph_dir, "resources")
  if !File.exists?(resources_dir) or !File.directory?(resources_dir)
    monograph_loggers[monograph_id].error("Error: #{File.basename(resources_dir)} is not a valid directory.")
    next
  end

  # Find the epub file name and determine whether it exists.
  epub_row = manifest.representative_row(:kind => "epub")
  epub_file_name = epub_row['file_name']
  epub_file = File.join(monograph_dir, epub_file_name)
  if !File.exist?(epub_file)
    monograph_loggers[monograph_id].error("Error: #{epub_file_name} not found in manifest for id #{monograph_id}")
    next
  end
  monograph_loggers[monograph_id].info("#{epub_file_name} found in manifest for id #{monograph_id}")

  # Determine if the resources directory contains any files.
  resource_file_list = Dir.glob(File.join(resources_dir, "*"))
  if resource_file_list.count == 0
    monograph_loggers[monograph_id].error("Error: #{File.basename(resources_dir)} contains no resources.")
    next
  end
  monograph_loggers[monograph_id].info("Resources directory exists containing #{resource_file_list.count} files.")

  # Determine if the resource map file exists.
  resource_map_file = File.join(process_dir, "resource_map.xml")
  if !File.exists?(resource_map_file)
    monograph_loggers[monograph_id].error("Error: resource map file #{File.basename(resource_map_file)} must exist.")
    next
  end

  # Create a new EPUB with the resource references detailed
  # in the resource map processed.
  processed_epub = UMPTG::Fulcrum::EPUBProcessor.process(
        epub_file: epub_file,
        default_actions: options.default_actions,
        resource_metadata: manifest,
        resource_map_file: resource_map_file,
        fulcrum_css_file: fulcrum_css_file,
        vendor: options.vendor,
        monograph_noid: monograph_noid,
        logger: monograph_loggers[monograph_id]
      )

  # Remove the old one if it exists.
  processed_epub_file = File.join(process_dir, File.basename(epub_file))
  FileUtils.remove_file(processed_epub_file, true)

  # Save the processed EPUB in the processing directory.
  processed_epub.save(epub_file: processed_epub_file)
end

monograph_loggers.each do |monograph_id, logger|
  logger.close
end
