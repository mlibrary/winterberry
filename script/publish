#!/usr/bin/env ruby
# frozen_string_literal: true

# Generate publishing steps

require 'optparse'
require 'ostruct'
require 'os'

# Process the script parameters.
options = OpenStruct.new
#options.fulcrum_dir = Dir.pwd
options.fulcrum_dir = OS.windows? ? "s:/Information\ Management/Fulcrum" : "/mnt/umptmm"
#options.fulcrum_dir = OS.windows? ? "c:/Users/Tim/Documents/UM/winterberry_test" : "/mnt/umptmm"
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-p <fulcrum_dir>] <publish_label> [<publish_label>..]"
  opts.on('-p', '--publisher_directory [DIRECTORY]', 'Publisher site directory') do |fulcrum_dir|
    options.fulcrum_dir = fulcrum_dir
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    puts opts
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  puts option_parser.help
  return
end

publish_label_list = ARGV

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

# Verify existence of the source/project root directories.
fulcrum_dir = File.expand_path(options.fulcrum_dir)
unless File.directory?(fulcrum_dir)
  puts "Error: source directory #{fulcrum_dir} does not exist."
  exit
end

# Determine publishing directory
publish_dir = File.join(fulcrum_dir, "tbelc", "PublishingSteps", "UMP")
unless File.directory?(publish_dir)
  puts "Error: source directory #{publish_dir} does not exist."
  exit
end
puts "Using directory #{File.basename(publish_dir)}"

# Determine the base monograph directory
monograph_dir = File.join(fulcrum_dir, "UMP")
publish_label_list.each do |publish_label|
  # Determine the publish step directory
  label_dir = File.join(publish_dir, publish_label)
  unless File.directory?(label_dir)
    puts "Error: no directory for label #{publish_label}"
    next
  end

  # Locate the monograph information file.
  monograph_info_file = File.join(label_dir, "isbn_noid_doi_id.csv")
  unless File.file?(monograph_info_file)
    puts "Error: missing file #{File.basename(monograph_info_file)} for label #{publish_label}"
    next
  end
  monograph_info = File.readlines(monograph_info_file)

  # Generate the publishing steps script file
  import_file = File.join(label_dir, "import.sh")
  File.open(import_file, "w") do |fp|
    fp.puts("# Import resources")
    monograph_info.each do |info_line|
      info = info_line.split(',')

      # Determine monograph directory
      isbn = info[0]
      resources_dir_list = Dir.glob(File.join(monograph_dir, "#{isbn}_*", "[Rr]esources*"))
      if resources_dir_list.empty?
        resources_dir = File.join(monograph_dir, "#{isbn}_unknown", "resources")
      else
        resources_dir = resources_dir_list.first
      end
      noid = info[1]

      fp.puts("sudo -u heliotrope-production RAILS_ENV=production bundle exec script/import -m #{info[1]} -d #{resources_dir}")
      fp.puts
    end
  end
  puts "Wrote script file #{File.basename(import_file)}"

  restrict_file = File.join(label_dir, "restrict_items.sh")
  File.open(restrict_file, "w") do |fp|
    fp.puts("# Create components")
    components_csv = File.join(label_dir, "noid_doi.csv")
    log_2020_file = File.join(label_dir, "restrict_items_ebc_2020.log")
    log_backlist_file = File.join(label_dir, "restrict_items_ebc_backlist.log")
    fp.puts("bundle exec ruby bin/restrict_items.rb -f #{components_csv} -p ebc_2020 >& #{log_2020_file}")
    fp.puts
    fp.puts("bundle exec ruby bin/restrict_items.rb -f #{components_csv} -p ebc_backlist >& #{log_backlist_file}")
  end
  puts "Wrote script file #{File.basename(restrict_file)}"
end
