#!/usr/bin/env ruby
# frozen_string_literal: true

# This script creates one or more initial project directory containing the
# necessary components for processing a monograph epub prior to publishing
# on Fulcrum.
#
# Invoke this script without any parameters to display the usage.
#
# The main function of this script is scan a monograph epub
# and generate a mapping of file names (images/audio/video/pdf/spreadsheets,
# etc.) to resource file names found within the monograph manifest.
#
# This directory will contain the following components:
#   - manifest.csv                        Monograph manifest
#   - xxxxxxxxxxxxx.epub                  Monograph epub where x+ is the
#                                         epub isbn.
#   - epub/META-INF/src/resource_map.csv  File that maps epub file names to
#                                         monograph resource file names.
#
# This functionality is separate from others since it is possible
# that the generated resource_map.csv may need to be manually edited before
# it can be used to finish processing the epub. File names used within
# the epub may not match their associated resource file names. Also,
# it is possible that a file contained within the epub may want its
# resource embedded in the epub while the rest of the files want
# their resources linked. This mapping will allow specification
# of each file name mapping.

require 'optparse'
require 'ostruct'

require 'csv'
require 'fileutils'
require 'zip'

# Process the script parameters.
options = OpenStruct.new
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-p <project_root_dir>] [-s <source_root_dir>] <monograph_noid> [<monograph_noid>..]"
  opts.on('-p', '--project_root_dir [DIRECTORY]', 'Root directory containing ebook project directories') do |project_root_dir|
    options.project_root_dir = project_root_dir
  end
  opts.on('-s', '--source_root_dir [DIRECTORY]', 'Root directory containing ebook source directories') do |source_root_dir|
    options.source_root_dir = source_root_dir
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    puts opts
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  puts option_parser.help
  return
end

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require_relative File.join(root_dir, 'lib', 'csvfile')
require_relative File.join(root_dir, 'lib', 'manifest')
require_relative File.join(root_dir, 'lib', 'metadata')
require_relative File.join(root_dir, 'lib', 'services')

# Determine the directory containing the source monograph epubs, and
# possibly the monograph manifest.
source_root_dir = options.source_root_dir || ENV['WINTERBERRY_FULCRUM_UMP_DIR'] || Dir.pwd

# Determine the root directory where the project directories should
# be created.
project_root_dir = options.project_root_dir || ENV['WINTERBERRY_PRODUCTION_DIR'] || Dir.pwd

# Rest of the parameters is a list of monograph noids.
noid_list = ARGV

# Verify existence of the source/project root directories.
source_root_dir = File.expand_path(source_root_dir)
if !File.exists?(source_root_dir)
  puts "Error: source directory #{source_root_dir} does not exist."
  exit
end
project_root_dir = File.expand_path(project_root_dir)
if !File.exists?(project_root_dir)
  puts "Error: project root directory #{project_root_dir} does not exist."
  exit
end

# Initialize the processor that scans the monograph epub .xhtml
# files and collects information concerning the contained resources.
fig_proc = FigureProcessor.new
parser = Nokogiri::XML::SAX::Parser.new(fig_proc)

noid_list.each do |noid|
  # Use the noid to retrieve the monograph manifest. First look and see
  # the file exists in the input directory. If so, load it. Otherwise,
  # attempt to download it from Fulcrum.
  src_manifest_file = File.join(source_root_dir, "#{noid}.csv")
  if File.exists?(src_manifest_file)
    puts "Loading manifest file #{File.basename(src_manifest_file)}"
    csv_body = File.read(src_manifest_file)
  else
    puts "Downloading manifest file for noid #{noid}"
    csv_body = HeliotropeService.new.monograph_noid_export(noid)
  end
  manifest_csv = CSVFile.read(:csv_body => csv_body)
  next if manifest_csv == nil

  # From the manifest, determine the ebook ISBN without dashes.
  ebook_isbn = Manifest.find_ebook_isbn(manifest_csv, noid)
  next if ebook_isbn == nil

  # Find the ebook source folder
  source_dir_list = Dir.glob(File.join(source_root_dir, "#{ebook_isbn}_*"))
  if source_dir_list.count == 0
    puts "Error: ebook source directory not found for noid #{noid}."
    next
  end
  source_dir = source_dir_list[0]
  puts "Multiple ebook source directories found for noid #{noid}. Using #{source_dir}" \
        if source_dir_list.count > 1
  puts "Using #{source_dir}" if source_dir_list.count == 1

  # Find the epub file name and determine whether it exists.
  # Currently, no heliotrope service for downloading a fileset exists,
  # otherwise it could be retrieved.
  epub_file_name = Manifest.find_epub_file_name(manifest_csv)
  src_epub_file = File.join(source_dir, epub_file_name)
  if !File.exist?(src_epub_file)
    puts "Error: no #{epub_file_name} not found for noid #{noid}"
    next
  end

  # Create the project directory.
  project_dir = File.join(project_root_dir, File.basename(source_dir))
  puts "Creating project #{project_dir}"
  STDOUT.flush
  FileUtils.mkdir_p project_dir

  # Save the manifest file
  Manifest.save(manifest_csv, File.join(project_dir, "manifest.csv"))

  # Copy the epub file.
  epub_file = File.join(project_dir, epub_file_name)
  puts "Copying epub file #{File.basename(epub_file)}"
  FileUtils.cp(src_epub_file, epub_file)

  # Scan the .xhtml files within the epub and collect the
  # resource information.
  Zip::File.open(epub_file) do |file|
    file.each do |entry|
      if File.extname(entry.name) == ".xhtml"
        parser.parse(entry.get_input_stream.read)
      end
    end
  end
  info_list = fig_proc.info_list

  # For each resource referenced with the epub, attempt to create a
  # resource mapping.
  actions_list = []
  info_list.each do |info|
    attrs_h = info.attrs.to_h

    # Determine resource file name. Using the file base name,
    # search the monograph manifest for associated resource information.
    # If not found, provide default information that could be
    # edited later.
    src = attrs_h['src']
    file_name = File.basename(src)
    fileset_row = Manifest.find_fileset(manifest_csv, file_name)
    if fileset_row['noid'].empty?
      puts "Warning: no resource mapping found for file #{file_name}"
    else
      resource_name = fileset_row['file_name']
      puts "File #{file_name} mapped to resource #{resource_name}"
    end
    action_row = {
          "file_name" => src,
          "resource_action" => "default",
          "resource_name" => fileset_row['file_name'],
          "noid" => fileset_row['noid'],
          "link" => fileset_row['link'],
          "embed_code" => fileset_row['embed_code']
    }
    actions_list << action_row
  end

  # Save the resource map file within a new epub structure
  # for archival purposes.
  epub_src_dir = File.join(project_dir, "epub", "META-INF", "src")
  FileUtils.mkdir_p epub_src_dir
  resource_map_file = File.join(epub_src_dir, "resource_map.csv")
  puts "Saving resource map file #{File.basename(resource_map_file)}"
  CSV.open(
          resource_map_file,
          "w",
          :write_headers=> true,
          :headers => ["NOID","File Name", "Resource Name", "Resource Action"]
        ) do |csv|
    actions_list.each do |action_row|

      csv_row = [
              action_row['noid'],
              action_row['file_name'],
              action_row['resource_name'],
              action_row['resource_action']
      ]

      csv << csv_row
    end
  end

  # Reset the processor for the next monograph noid
  fig_proc.reset

end
