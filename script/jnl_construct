#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'ostruct'

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require_relative File.join(root_dir, "lib", "logger")

script_logger = UMPTG::Logger.create(logger_fp: STDOUT)

# Process the script parameters.
options = OpenStruct.new
options.fulcrum_host = nil
options.journal_dir = Dir.pwd
options.generate_xhtml = false
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-f production|preview|staging] [-d journal_dir] [-x] [journal_name...]"
  opts.on('-d', '--directory [DIRECTORY]', 'Journal directory') do |da|
    options.journal_dir = da
  end
  opts.on('-f', '--fulcrum_host host', 'Fulcrum environment') do |fulcrum_host|
    options.fulcrum_host = fulcrum_host
  end
  opts.on('-x', '--xhtml', 'Generate XHTML') do |da|
    options.generate_xhtml = true
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    script_logger.info(opts)
    exit 0
  end
end
option_parser.parse!(ARGV)

# Journal directory exists?
journal_dir = File.expand_path(options.journal_dir)
unless File.directory?(journal_dir)
  script_logger.error("journal directory not found \"#{journal_dir}.")
  exit 1
end

# Journal directory valid?
articles_dir = File.join(journal_dir, "articles")
dlxs_dir = File.join(journal_dir, "dlxs")
resources_dir = File.join(journal_dir, "resources")
unless File.directory?(articles_dir) and File.directory?(dlxs_dir) and File.directory?(resources_dir)
  script_logger.error("journal directory invalid \"#{File.basename(journal_dir)}.")
  exit 1
end

journal_name_list = ARGV
if journal_name_list.empty?
  journal_name_list = []
  Dir.glob(File.join(dlxs_dir, "*.xml")).each do |dlxs_file|
    journal_name_list << File.basename(dlxs_file, ".*")
  end
end

require_relative File.join(root_dir, 'lib', 'xslt')
require_relative File.join(root_dir, "lib", "fulcrum")
require_relative File.join(root_dir, "lib", "services")

# Create the serivce for retrieving the manifest.
service = UMPTG::Services::Heliotrope.new(
                :fulcrum_host => options.fulcrum_host
              )

require 'fileutils'
require 'nokogiri'
require 'htmlentities'

dlxs2jats_xsl_file = File.join(root_dir, "lib", "journal", "xsl", "dlxs2jats.xsl")
jats2html_xsl_file = File.join(root_dir, "lib", "journal", "xsl", "jats-html.xsl")

KSP='#'
RSP=';'
FSP='^'
VSP='='
RESOURCE_MARKUP = "<resource entity=\"%s\" file_name=\"%s\" file_type=\"%s\" link=\"%s\" embed_link=\"%s\" doi=\"%s\"><title>%s</title><caption>%s</caption><embed_code>%s</embed_code></resource>"

def detect(path)
  header = File.binread(path, 50).downcase
  case
  when header[0..2] == 'gif'
    return 'gif'
  when header[1..3] == 'png'
    return 'png'
  when header[5..8] == 'jfif'
    return 'jpg'
  when header[28..30] == 'mp4'
    return 'mp4'
  when header[1..3] == 'pdf'
    return 'pdf'
  end
  return ""
end

encoder = HTMLEntities.new
journal_name_list.each do |journal_name|
  dlxs_file = File.join(dlxs_dir, journal_name + ".xml")
  if !File.exists?(dlxs_file)
    script_logger.error("#{journal_name}: no DLXS file.")
    next
  end

  article_dir = File.join(articles_dir, journal_name)
  FileUtils.mkdir_p article_dir

  jats_file = File.join(article_dir, journal_name + "_jats.xml")
  script_logger.info("#{journal_name}: #{File.basename(dlxs_file)} ==> #{File.basename(jats_file)}")

  # Pass the resource file names as a parameter to the XSLT.
  resource_file_list = Dir.glob(File.join(resources_dir, "#{journal_name}*"))

  resource_file_table = {}
  resource_file_list.each do |resource_file|
    fname = File.basename(resource_file)
    key = File.basename(fname, '.*')
    next if key.end_with?("-lg")

=begin
    # If hi-res, then use this image.
    if key.end_with?("-lg")
      key = key[0..-4]
      resource_file_table[key] = resource_file
      next
    end
=end

    # Not hi-res, use this one if one has
    # not been found to this point.
    unless resource_file_table.key?(key)
      resource_file_table[key] = resource_file
    end
  end

  # If a monograph exists, retrieve its manifest
  manifest = nil
  id2csv_body_list = service.monograph_export(identifier: "#{journal_name}")
  if id2csv_body_list[journal_name].empty?
    script_logger.warn("no manifest found for id #{journal_name}")
  else
    manifest = UMPTG::Fulcrum::Manifest::Document.new(
                  csv_body: id2csv_body_list[journal_name].first
                )
    if manifest.nil?
      script_logger.error("generating manifest CSV for #{journal_name}")
    end
    script_logger.info("manifest found for #{journal_name}")
  end

  # Copy the resource files to be used
  # and construct the XSLT parameter.
  resource_list = []
  resource_list_param = ""
  resource_file_table.each do |key,resource_file|
    script_logger.info("Copying resource #{File.basename(resource_file)}")
    FileUtils.cp(resource_file, article_dir)

    file_type = detect(resource_file)

    link = title = caption = embed_link = doi = embed_code = ""
    fileset = manifest.fileset(File.basename(resource_file)) unless manifest.nil?
    unless fileset.nil?
      link = fileset['link'][12..-3]

      embed_markup = fileset['embed_code']
      unless embed_markup.nil? or embed_markup.empty?
        embed_doc = Nokogiri::XML::DocumentFragment.parse(embed_markup)
        iframe_node = embed_doc.xpath(".//*[local-name()='iframe']").first
        embed_link = iframe_node['src']
        puts "src:#{embed_link}" unless iframe_node.nil?
      end

      title = fileset['title']
      caption = fileset['caption']
      doi = fileset['doi']
      embed_code = fileset['embed_code']
    end
    #resource_list_param += "#{key}:#{File.join("resources", File.basename(resource_file))};"
    resource_list_param += "#{key}#{KSP}file_name#{VSP}#{File.basename(resource_file)}#{FSP}file_type#{VSP}#{file_type}#{FSP}link#{VSP}#{link}#{FSP}embed_link#{VSP}#{embed_link}#{FSP}caption#{VSP}#{caption}#{FSP}title#{VSP}#{title}#{RSP}"
    resource_list << sprintf(RESOURCE_MARKUP, key, File.basename(resource_file), file_type, link, embed_link, doi, title, caption, encoder.encode(embed_code))
  end
  resource_list_param2 = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>" + resource_list.join + "</resources>"
  rfile = File.expand_path('junk.xml')
  File.write(rfile, resource_list_param2)
  resource_list_param = resource_list_param[0..-3]

  params = {
              "image_list" => URI(rfile)
           }

  rc = UMPTG::XSLT.transform(
          xslpath: dlxs2jats_xsl_file,
          srcpath: dlxs_file,
          destpath: jats_file,
          logger: script_logger,
          parameters: params
          )
  #FileUtils.rm(rfile)

  if rc and options.generate_xhtml
    html_file = File.join(File.dirname(jats_file), File.basename(jats_file, ".*") + ".html")
    UMPTG::XSLT.transform(
            xslpath: jats2html_xsl_file,
            srcpath: jats_file,
            destpath: html_file,
            logger: script_logger
            )
  end
end
