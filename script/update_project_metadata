#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'ostruct'

require 'csv'
require 'fileutils'
require 'zip'

# Process the script parameters.
options = OpenStruct.new
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} <project_dir> [<project_dir>..]"
  opts.on_tail('-h', '--help', 'Print this help message') do
    puts opts
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  puts option_parser.help
  return
end

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require_relative File.join(root_dir, 'lib', 'csv_file')
require_relative File.join(root_dir, 'lib', 'manifest')
require_relative File.join(root_dir, 'lib', 'metadata')

# Rest of the parameters is a list of project directories.
project_dir_list = ARGV

# Initialize the processor that scans the monograph epub .xhtml
# files and collects information concerning the contained resources.
fig_proc = FigureProcessor.new
html_parser = HTMLParser.new(fig_proc)
parser = Nokogiri::XML::SAX::Parser.new(html_parser)

# For each project directory, collect the epub captions/alt text.
project_dir_list.each do |project_dir|
  # Determine if the monograph manifest exists.
  manifest_file = File.join(project_dir, "manifest.csv")
  if !File.exists?(manifest_file)
    puts "Error: missing manifest file for project #{File.basename(project_dir)}"
    next
  end

  # Determine if the resource mapping file exists.
  epub_src_dir = File.join(project_dir, "epub", "META-INF", "src")
  resource_map_file = File.join(epub_src_dir, "resource_map.csv")
  if !File.exists?(resource_map_file)
    puts "Error: missing resource map file for project #{File.basename(project_dir)}"
    next
  end

  # Load the manifest file
  manifest_csv = CSVFile.read_file(:csv_path => manifest_file)
  if manifest_csv == nil
    puts "Error: reading manifest file for project #{File.basename(project_dir)}"
    next
  end

  # Find the epub file name.
  epub_file_name = Manifest.find_epub_file_name(manifest_csv)
  epub_file = File.join(project_dir, epub_file_name)
  if !File.exist?(epub_file)
    puts "Error: no #{epub_file} not found for project #{File.basename(project_dir)}"
    next
  end

  # Load the resource map file
  resource_map_csv = CSVFile.read_file(:csv_path => resource_map_file)
  if resource_map_csv == nil
    puts "Error: reading resource map file for project #{File.basename(project_dir)}"
    next
  end

  # Parse the epub files
  Zip::File.open(epub_file) do |file|
    file.each do |entry|
      if File.extname(entry.name) == ".xhtml"
        parser.parse(entry.get_input_stream.read)
      end
    end
  end
  info_list = fig_proc.info_list

  # For each resource referenced with the epub, associate its
  # noid with the caption/alt text.
  caption_list = []
  info_list.each do |info|
    attrs_h = info.attrs.to_h

    # Determine the resource file name
    src = attrs_h['src']
    file_name = File.basename(src)

    # Attempt to find a resource mapping. If not found,
    # then a row with default values is returned.
    map_row = resource_map_csv.find {|row| row['file_name'] == src }
    if map_row == nil
      puts "Warning: no resource mapping found for file #{src}"
    else
      file_name = File.basename(map_row['file_name'])
      puts "File #{src} mapped to name #{file_name}"
    end

    # Attempt the monograph resource information from the manifest.
    fileset_row = Manifest.find_fileset(manifest_csv, file_name)
    if fileset_row['noid'].empty?
      puts "Warning: no resource entry found for file #{src}"
    else
      resource_name = fileset_row['file_name']
      puts "Name #{file_name} mapped to resource #{resource_name}"
    end

    # Create an entry for this resource with its noid,
    # caption/alt text.
    caption_row = {
          "noid" => fileset_row['noid'],
          "alternative_text" => attrs_h['alt'],
          "caption" => info.caption
    #      "alternative_text" => encoder.encode(attrs_h['alt']),
    #      "caption" => encoder.encode(info.caption)
    }
    caption_list << caption_row
  end

  # Save the captions/alt text metadata file.
  captions_file = File.join(project_dir, "alt_captions.csv")
  puts "Saving alt_text/captions file #{File.basename(captions_file)}"
  CSV.open(
          captions_file,
          "w",
          :write_headers=> true,
          :headers => ["NOID","Alternative Text","Caption"]
        ) do |csv|
    caption_list.each do |caption_row|

      csv_row = [
              caption_row['noid'],
              caption_row['alternative_text'],
              caption_row['caption']
            ]

      csv << csv_row
    end
  end

  # Reset the processor for the next project directory.
  fig_proc.reset
end
