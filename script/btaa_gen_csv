#!/usr/bin/env ruby
# frozen_string_literal: true

# Script takes a list of EPUBs, determines the list of
# CSS stylesheets and outputs info about each, and
# possibly replaces stylesheets

require 'optparse'
require 'ostruct'
require 'os'

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require_relative File.join(root_dir, "lib", "logger")

script_logger = UMPTG::Logger.create(logger_fp: STDOUT)

# Process the script parameters.
options = OpenStruct.new
options.write_mono_file = false
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-m] <csv_file> [<monograph_dir>..]"
  opts.on('-m', '--mono', 'Write monograph file') do |m|
    options.write_mono_file = true
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    script_logger.info(opts)
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  script_logger.info(option_parser.help)
  exit 0
end

csv_file = ARGV[0]
monograph_dir_list = ARGV[1..-1]

require 'csv'

require_relative File.join(root_dir, 'lib', 'fulcrum', 'manifest')

MONOGRAPH_HEADERS = UMPTG::Fulcrum::Manifest::Validation::CollectionSchema.headers()
=begin
MONOGRAPH_HEADERS = MONOGRAPH_HEADERS \
      - [ "File Name" ] - [ "Representative Kind" ] - [ "Resource Type" ] \
      - [ "Alternative Text" ] - [ "Caption" ] - [ "Content Type" ] \
      - [ "Exclusive to Fulcrum" ] - [ "External Resource URL" ] - [ "NOID" ] \
      - [ "Section" ] - [ "Redirect to" ] - [ "Transcript" ] \
      - [ "Translation" ] - [ "Link" ] - [ "Sort Date" ]
=end

csv_file = File.expand_path(csv_file)
unless File.exists?(csv_file)
  script_logger.error("invalid CSV file path #{csv_file}.")
  exit 1
end
script_logger.info("*** processing #{File.basename(csv_file)} ***")
STDOUT.flush

=begin
fm_csv = CSV.parse(
          File.read(csv_file),
          :headers => true,
          #:header_converters=> lambda {|f| fm_header_convert(f)},
          :return_headers => false
        )

# Each title may have multiple rows. The extra
# rows may contain additional ISBNs. Traverse
# the rows and condense the extra ISBNs into
# a new column named ISBN(s).
fm_row_list = []
frow = nil
fm_csv.each do |fm_row|
  title = fm_row['Title']

  unless title.nil? or title.strip.empty?
    #script_logger.info("title:#{title}")
    frow = fm_row
    frow['ISBN(s)'] = ""
    frow['ISBN_SEARCH'] = ""
    fm_row_list << frow
  end
  isbn = fm_row['ISBN13'].strip
  frow['ISBN_SEARCH'] += isbn + ";"
  isbn = "#{isbn[0..2]}-#{isbn[3..3]}-#{isbn[4..8]}-#{isbn[9..11]}-#{isbn[12..12]}"
  format = fm_row['Format'].strip.downcase
  entry = "#{isbn} (#{format});"
  frow['ISBN(s)'] += entry
end

# Map the TMM columns to Fulcrum import columns.
monograph_row_list = []
fm_row_list.each do |fm_row|
  monograph_row = {}

  # Make sure required fields are filled in:
  #   Title, Publisher (citation), Creator(s), Pub Year,
  #   Pub Location, Handle, Identifier(s), ISBN(s)
  unless fm_row.nil?
    title = fm_row['Title']
    title += ": #{fm_row['Subtitle']}" unless fm_row['Subtitle'].nil? or fm_row['Subtitle'].empty?
    monograph_row['Title'] = title

    author_list = []
    (1..4).each do |ndx|
      lname = fm_row["authorlastname#{ndx}"]
      unless lname.nil? or lname.empty?
        fname = fm_row["authorfirstname#{ndx}"]
        role = fm_row["authortype#{ndx}"]
        author = "#{lname}, #{fname}"
        author += " (#{role})" unless role.nil? or role.strip.empty?
        author_list << author
      end
    end
    monograph_row['Creator(s)'] = author_list.join(';')

    fm_row.each do |key,val|
      next if key.nil? or key.strip.empty?

      case key
      when 'ID'
        monograph_row['Identifier(s)'] = val.downcase
      when 'Publisher'
        monograph_row['Publisher'] = val
      when 'Pub City 1'
        monograph_row['Pub Location'] = val
      when 'Book Description Marketing'
        monograph_row['Description'] = val
      when 'Open Access Funder'
        monograph_row['Funder'] = val
      when 'Open Access Avail'
        monograph_row['Open Access?'] = val
      when 'Subjects'
        monograph_row['Subject'] = val
      when 'Handle Prefix'
      when 'ISBN13'
      when 'Pub Format', 'Pub Format 2'
      when 'Pub Date 2', 'Pub Date 3'
      when 'Title', 'Subtitle'
      else
        monograph_row[key] = val
      end
    end
  end
  monograph_row_list << monograph_row
end

# Generate a new CSV listing Fulcrum metadata
# for each title.
fulcrum_body = CSV.generate(
        :headers => MONOGRAPH_HEADERS + [ 'ISBN_SEARCH'],
        :write_headers => true
      ) do |csv|
  monograph_row_list.each do |monograph_row|
    csv << monograph_row
  end
end

if options.write_mono_file
  # Save the Fulcrum metadata CSV file.
  fulcrum_file = File.join(File.dirname(csv_file), File.basename(csv_file, ".*") + "_mono" + File.extname(csv_file))
  script_logger.info("Creating metadata file #{fulcrum_file}")
  File.write(fulcrum_file, fulcrum_body)
end
=end

fulcrum_body = File.read(csv_file)

fulcrum_csv = CSV.parse(
          fulcrum_body,
          headers: true,
          return_headers: false
          )

monograph_dir_list.each do |monograph_dir|
  monograph_dir = File.expand_path(monograph_dir)
  unless File.directory?(monograph_dir)
    script_logger.error("directory \"#{File.basename(monograph_dir)}\" does not exist.")
    next
  end
  script_logger.info("processing directory \"#{File.basename(monograph_dir)}\"")

  isbn = File.basename(monograph_dir)[0..12]

  # Search CSV for monograph metadata. Directory name
  # is the search key. First, search HEBID field (HEBID).
  # If fails, then search the ISBN fields (ISBN[1-3]_13).
  fm_row_list = fulcrum_csv.select do |row|
    (!row['ISBN(s)'].nil? and row['ISBN(s)'].gsub(/\-/,'').include?(isbn))
    #(!row['ISBN_SEARCH'].nil? and row['ISBN_SEARCH'].include?(isbn))
  end
  if fm_row_list.empty?
    script_logger.warn("no CSV row found for #{isbn}. Skipping.")
    next
  end
  script_logger.info("Found CSV row for #{isbn}.")

  monograph_row = fm_row_list.first

  file_list = Dir.glob(File.join(monograph_dir, "*"))
  rep_row_list = []
  file_list.each do |fl|
    file_name = File.basename(fl)
    ext = File.extname(file_name)
    next if ext.nil? or ext.strip.empty?

    case ext.strip.downcase
    when '.jpg', '.png', '.bmp', '.jpeg', '.tif'
      rep_kind = 'cover'
    when '.epub'
      rep_kind = 'epub'
    when '.pdf'
      rep_kind = 'pdf_ebook'
    else
      script_logger.warn("skipping file #{file_name}")
      next
    end

    rep_row_list << {
          'File Name' => file_name,
          'Title' => file_name,
          'Representative Kind' => rep_kind
      }
  end

  monograph_row['File Name'] = '://:MONOGRAPH://:'
  new_monograph_row = {}
  MONOGRAPH_HEADERS.each {|h| new_monograph_row[h] = monograph_row[h] }

  manifest_body = CSV.generate(
          :headers => MONOGRAPH_HEADERS,
          :write_headers => true
        ) do |csv|
    csv << { "File Name" => "***row left intentionally blank***" }
    rep_row_list.each do |rep_row|
      csv << rep_row
    end
    #csv << monograph_row
    csv << new_monograph_row
  end

  # Save the Fulcrum metadata CSV file.
  fulcrum_file = File.join(monograph_dir, "manifest.csv")
  script_logger.info("Creating metadata file #{fulcrum_file}")
  File.write(fulcrum_file, manifest_body)
end


