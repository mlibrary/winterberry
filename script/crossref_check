#!/usr/bin/env ruby
# frozen_string_literal: true

# Script compares the proposed Crossref submission
# with current DOI registrations

require 'optparse'
require 'ostruct'
require 'os'

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require_relative File.join(root_dir, "lib", "logger")

script_logger = UMPTG::Logger.create(logger_fp: STDOUT)

# Process the script parameters.
options = OpenStruct.new
options.message_type = :works
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} submission_file [doi...]"
  opts.on_tail('-h', '--help', 'Print this help message') do
    script_logger.info(opts)
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  script_logger.info(option_parser.help)
  return
end

# Process the command line parameters.
submission_file = ARGV[0]
doi_list = ARGV[1..-1]

DOI_DATA_XPATH = <<-SXPATH
//*[
local-name()='book' and @book_type='monograph'
]/*[
local-name()='book_metadata'
]
SXPATH

require 'nokogiri'
require 'serrano'
require 'uri'

class DOIRecord
  attr_reader :doi_data_node, :doi, :print_isbn, :pub_year, :doi_prefixed, :url_proposed
  attr_accessor :url_actual

  def initialize(args = {})
    @doi_data_node = args[:doi_data_node]
    @pub_year = @doi_data_node.xpath("./*[local-name()='publication_date']/*[local-name()='year']").first.text
    @print_isbn = @doi_data_node.xpath("./*[local-name()='isbn' and @media_type='print']").first.text
    @doi = @doi_data_node.xpath("./*[local-name()='doi_data']/*[local-name()='doi']").first.text
    @doi_prefixed = "http://doi.org/" + @doi

    @url_proposed = @doi_data_node.xpath("./*[local-name()='doi_data']/*[local-name()='resource']").first.text
    @url_actual = ""
  end
end

submission_file = File.expand_path(submission_file)
unless File.exist?(submission_file)
  script_logger.error("Submission file doesn't exist, #{submission_file}")
  exit(1)
end
submission_doc = Nokogiri::XML(File.open(submission_file))

Serrano.configuration do |config|
  config.base_url = "https://api.crossref.org"
  config.mailto = "mpub.xref@gmail.com"
end

def log_doi(script_logger, record)
  if record.nil?
    script_logger.warn("2,no DOI record found #{doi}")
    return
  end
  uri_actual_host = URI(record.url_actual).host
  uri_actual_host.delete_prefix!('www.') unless uri_actual_host.nil?
  uri_proposed_host = URI(record.url_proposed).host
  uri_proposed_host.delete_prefix!('www.') unless uri_proposed_host.nil?

  return if uri_actual_host == uri_proposed_host
  #return if uri_actual_host == "hdl.handle.net"

  script_logger.info("#{record.doi}:#{record.print_isbn},#{record.url_actual},#{record.url_proposed}")
end

DOI_SKIP_LIST = [
        "10.3998/mpub.11871089",
        "10.3998/mpub.12912253",
        "10.3998/mpub.14418165",
        "10.3998/mpub.14328063",
        "10.3998/mpub.12838586",
        "10.3998/mpub.14376540",
        "10.3998/mpub.12865688",
        "10.3998/mpub.12578382",
        "10.3998/mpub.12123587",
        "10.3998/mpub.12827650",
        "10.3998/mpub.12067961",
        "10.3998/mpub.14386272",
        "10.3998/mpub.12783158",
        "10.3998/mpub.12823887"
    ]
ISBN_SKIP_LIST = [
"9780472039784","9780472074839","9780472077069","9780472077120","9780472076673","9780472076789","9780472039777",
"9780472133543","9780472133550","9780472039227","9780472076970","9780472904525","9780472077021","9780472133536",
"9780472076734","9780472039722","9780472039746","9780472076260","9780472076857","9780472077151","9780472076741",
"9780472077267","9780472076901","9780472074372","9780472133307","9780472077137","9780472076796","9780472076918",
"9780472077052","9780472077113","9780472076833","9780472076956","9780472133529","9780472077199","9780472076765",
"9780472076932","9780472077175","9780472999071","9780472039708","9780472076802","9780472076710","9780472039715",
"9780472076413","9780472076864","9780472076826","9780472076994","9780472076994","9780472077076","9780472076987",
"9780472076949","9780472076666","9780472075218","9780472039111","9780472077205","9780472039845","9780472076642",
"9780472999088","9780472076758","9780472076895","9780472076727","9780472039661","9780472039807","9780472076680",
"9780472077007","9780472039791","9780472077182","9780472076567","9780472131952","9780472076871","9780472077243",
"9780472077212","9780472076840","9780472076246","9780472077250","9780472076963","9780472039678","9780472133574",
"9780472076819","9780472077144","9780472077090","9780472076086","9780472133512","9780472076888","9780472039838",
"9780472077083","9780472077045","9780472133567","9780472076925","9780472077014","9780472077281","9780472077168",
"9780472077106","9780472077038","9780472133598","9780472133291","9780472133581"
    ]

doi_records = {}
doi_data_node_list = submission_doc.xpath(DOI_DATA_XPATH)
doi_data_node_list.each do |doi_data_node|
  doi_record = DOIRecord.new(
                      doi_data_node: doi_data_node
                      )
  next if DOI_SKIP_LIST.include?(doi_record.doi)
  #next if ISBN_SKIP_LIST.include?(doi_record.print_isbn)
  doi_records[doi_record.doi] = doi_record
end

doi_list_2024 = []
if doi_list.empty?
  doi_records.each do |doi,record|
    #if record.pub_year.to_i > 2023
    if record.pub_year.to_i == 2025
      #doi_list_2024 << record.doi
      doi_list << record.doi
    else
      #doi_list << record.doi
    end
  end
end

response_list = []

=begin
doi_list_2024_failed = []
doi_list_2024.each do |doi|
  begin
    response = Serrano.works(ids: [doi])
    #script_logger.info(doi)
  rescue StandardError => e
    script_logger.error(e.message)
    doi_list_2024_failed << doi
  end
end
doi_list_2024_failed.each {|doi| log_doi(script_logger, doi_records[doi]) }
exit(0)
=end

response_list = []
case options.message_type
when :funders
  response_list = Serrano.funders(ids: doi_list)
when :works
  begin
    response_list = Serrano.works(ids: doi_list)
  rescue StandardError => e
    script_logger.error(e.message)
    exit(1)
  end
else
  script_logger.error("message type #{options.message_type} not supported.")
  exit(1)
end

response_list.each do |response|
  unless response["status"].downcase == "ok"
    script_logger.error("#{options.message_type} request failed,#{response}")
    next
  end
  script_logger.info("*** message-type:#{response['message-type']}, version:#{response['message-version']} ***")

  message = response["message"]
  doi = message["DOI"]
  if doi.nil?
    script_logger.warn("no DOI")
    next
  end
  resource = message["resource"]
  if resource.nil?
    script_logger.warn("no resource")
    next
  end
  url = resource["primary"]["URL"]

  doi_record = doi_records[doi]
  if doi_record.nil?
    script_logger.warn("no DOI record found #{doi}")
    next
  end
  doi_record.url_actual = url
end

doi_list.each {|doi| log_doi(script_logger, doi_records[doi]) }
#doi_list_2024.each {|doi| log_doi(script_logger, doi_records[doi]) }

=begin
doi_records.each do |doi,record|
  #next if record.url_actual == record.url_proposed
  #script_logger.info("#{record.url_actual},#{record.url_proposed}")
  uri_actual_host = URI(record.url_actual).host
  uri_actual_host.delete_prefix!('www.') unless uri_actual_host.nil?
  uri_proposed_host = URI(record.url_proposed).host
  uri_proposed_host.delete_prefix!('www.') unless uri_proposed_host.nil?
  next if uri_actual_host == uri_proposed_host
  next if uri_actual_host == "hdl.handle.net"
  #script_logger.warn("#{uri_actual_host},#{uri_proposed_host}")
  script_logger.info("#{record.url_actual},#{record.url_proposed}")
end
=end
