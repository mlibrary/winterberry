#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'ostruct'

# Process the script parameters.
options = OpenStruct.new
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-s <source_root_dir>] <monograph_noid> [<monograph_noid>..]"
  opts.on('-s', '--source_root_dir [DIRECTORY]', 'Root directory containing ebook source directories') do |source_root_dir|
    options.source_root_dir = source_root_dir
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    puts opts
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  puts option_parser.help
  return
end

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

# Determine the directory containing the source monograph epubs, and
# possibly the monograph manifest.
source_root_dir = options.source_root_dir || ENV['WINTERBERRY_FULCRUM_UMP_DIR'] || Dir.pwd

# Verify existence of the source/project root directories.
source_root_dir = File.expand_path(source_root_dir)
if !File.exists?(source_root_dir)
  puts "Error: source directory #{source_root_dir} does not exist."
  exit
end

monograph_noid_list = ARGV

require 'csv'
require 'fileutils'
require 'zip'

require_relative File.join(root_dir, 'lib', 'csvfile')
require_relative File.join(root_dir, 'lib', 'manifest')
require_relative File.join(root_dir, 'lib', 'metadata')
require_relative File.join(root_dir, 'lib', 'services')

# Initialize the processor that scans the monograph epub .xhtml
# files and collects information concerning the contained resources.
fig_proc = FigureProcessor.new
parser = Nokogiri::XML::SAX::Parser.new(fig_proc)

caption_file_headers = [ "File Name", "Resource Name", "Alternative Text", "Caption" ]

monograph_noid_list.each do |monograph_noid|
  # Use the noid to retrieve the monograph manifest. First look and see
  # the file exists in the input directory. If so, load it. Otherwise,
  # attempt to download it from Fulcrum.
  puts "*" * 10 + " #{monograph_noid} " + "*" * 10

  puts "Downloading manifest file for noid #{monograph_noid}"
  csv_body = HeliotropeService.new.monograph_noid_export(monograph_noid)
  manifest_csv = CSVFile.read(:csv_body => csv_body)
  next if manifest_csv == nil

  # From the manifest, determine the ebook ISBN without dashes.
  ebook_isbn = Manifest.find_ebook_isbn(manifest_csv, monograph_noid)
  next if ebook_isbn == nil

  # Find the ebook source folder
  source_dir_list = Dir.glob(File.join(source_root_dir, "#{ebook_isbn}_*"))
  if source_dir_list.count == 0
    puts "Error: ebook source directory not found for noid #{monograph_noid}."
    next
  end
  source_dir = source_dir_list[0]
  puts "Multiple ebook source directories found for noid #{monograph_noid}. Using #{source_dir}" \
        if source_dir_list.count > 1
  puts "Using #{source_dir}" if source_dir_list.count == 1

  # Determine if the resources directory exists.
  resources_dir = File.join(source_dir, "resources")
  if !File.exists?(resources_dir) or !File.directory?(resources_dir)
    puts "Error: File.basename(resources_dir) is not a valid directory."
    next
  end

  # Determine if the resources directory contains any files.
  resource_file_list = Dir.glob(File.join(resources_dir, "*"))
  if resource_file_list.count == 0
    puts "Error: File.basename(resources_dir) contains no resources."
    next
  end

  # Determine if the user metadata CSV file exists.
  user_metadata_file = File.join(resources_dir, "#{File.basename(source_dir)}.csv")
  if !File.exists?(user_metadata_file)
    puts "Error: File.basename(user_metadata_file) does not exist."
    next
  end

  # Find the epub file name and determine whether it exists.
  # Currently, no heliotrope service for downloading a fileset exists,
  # otherwise it could be retrieved.
  epub_file_name = Manifest.find_epub_file_name(manifest_csv)
  epub_file = File.join(source_dir, epub_file_name)
  if !File.exist?(epub_file)
    puts "Error: #{epub_file_name} not found in manifest for noid #{monograph_noid}"
    next
  end

  # If a resource map file exists, then load it.
  process_dir = File.join(source_dir, "resource_processing")
  resource_map_file = File.join(process_dir, "resource_map.csv")
  resource_map = nil
  if File.exists?(resource_map_file)
    puts "NOTE: using resource map file #{File.basename(resource_map_file)}"
  end

  # Scan the .xhtml files within the epub and collect the
  # resource information.
  Zip::File.open(epub_file) do |file|
    file.each do |entry|
      if File.extname(entry.name) == ".xhtml"
        parser.parse(entry.get_input_stream.read)
      end
    end
  end
  ref_list = fig_proc.info_list

  # For each resource referenced with the epub, associate its
  # noid with the caption/alt text.
  caption_list = []
  ref_list.each do |info|
    attrs_h = info.attrs.to_h

    # Determine the resource file name
    src = attrs_h['src']
    file_name = File.basename(src)

    # If a resource map is being used, attempt to map
    # the file name to a resource name.
    if resource_map != nil
      # Attempt to find a resource mapping. If not found,
      # then a row with default values is returned.
      map_row = resource_map_csv.find {|row| row['file_name'] == src }
      if map_row == nil
        puts "Warning: no resource mapping found for file #{src}"
      else
        file_name = File.basename(map_row['file_name'])
        puts "File #{src} mapped to name #{file_name}"
      end
    end

    # Determine if this resource exists in the resources directory.
    # Check on the basename as the reference extension and
    # the resource extension can differ (.jpg => .pdf).
    rfile_list = Dir.glob(File.join(resources_dir, "#{File.basename(file_name, File.extname(file_name))}.*"))
    if rfile_list.count == 0
      puts "Warning: resource #{src} does not exist."
      next
    end
    rfile = rfile_list[0]
    if rfile_list.count > 1
      puts "Warning: resource #{src} has #{rfile_list.count} entries. Using #{File.basename(rfile)}."
    end

    # Create an entry for this resource with its noid,
    # caption/alt text.
    caption_row = {
          "File Name" => src,
          "Resource Name" => File.basename(rfile),
          "Alternative Text" => attrs_h['alt'],
          "Caption" => info.caption
    #      "Alternative Text" => encoder.encode(attrs_h['alt']),
    #      "Caption" => encoder.encode(info.caption)
    }
    caption_list << caption_row
  end

  # Save the captions in a CSV.
  caption_file = File.join(process_dir, "captions.csv")
  CSV.open(
          caption_file,
          "w",
          :write_headers=> true,
          :headers => caption_file_headers
        ) do |csv|

    caption_list.each do |row|
      csv << row
    end
  end

  # Load the user metadata CSV file.
  begin
    user_metadata_csv = CSV.parse(
              File.read(File.expand_path(user_metadata_file)),
              :headers => true,
              :return_headers => false
              )
  rescue Exception => e
    puts e.message
    return nil
  end

  # Traverse the user metadata file and insert the caption
  # and alternative text. Save it to a new CSV file.
  monograph_metadata_file = File.join(process_dir, File.basename(user_metadata_file))
  CSV.open(
          monograph_metadata_file,
          "w",
          :write_headers=> true,
          :headers => user_metadata_csv.headers
        ) do |csv|

    user_metadata_csv.each do |row|
      resource_name = row["File Name"]
      base_resource_name = File.basename(resource_name, File.extname(resource_name))
      caption_row = caption_list.find {|entry| File.basename(entry["File Name"], File.extname(entry["File Name"])) == base_resource_name }

      new_row = {}
      row.each do |key,value|
        new_row[key] = value.force_encoding("UTF-8") if value != nil
      end
      if caption_row != nil
        puts "Found caption/alt text for resource #{resource_name}."
        new_row["Caption"] = caption_row["Caption"]
        new_row["Alternative Text"] = caption_row["Alternative Text"]
      else
        puts "Warning: no caption/alt text found for resource #{resource_name}."
      end

      csv << new_row
    end
  end

  # Reset the processor for the next project directory.
  fig_proc.reset

end
