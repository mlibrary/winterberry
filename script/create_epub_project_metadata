#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'ostruct'

require 'csv'
require 'fileutils'
require 'zip'

# Process the script parameters.
options = OpenStruct.new
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} <project_dir> [<project_dir>..]"
  opts.on_tail('-h', '--help', 'Print this help message') do
    puts opts
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  puts option_parser.help
  return
end

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require_relative File.join(root_dir, 'lib', 'metadata')

project_dir_list = ARGV

# Initialize the processor that scans the OPF file
# for the path to the cover image
opf_proc = OPFProcessor.new
parser = Nokogiri::XML::SAX::Parser.new(opf_proc)

project_dir_list.each do |project_dir|
  project_dir = File.expand_path(project_dir)

  puts "Processing #{File.basename(project_dir)}"
  STDOUT.flush

  dest_output_dir = File.join(project_dir, 'dest')

  # Locate the EPUB file.
  epub_file_list = Dir.glob(File.join(project_dir,'**','*.epub'))
  if epub_file_list.count == 0
    puts "Error: EPUB file not found for project #{File.basename(project_dir)}"
    next
  end
  if epub_file_list.count > 1
    puts "Error: multiple EPUB files found for project #{File.basename(project_dir)}"
    next
  end
  epub_file = epub_file_list.first

  # Locate the EPUB OPF file.
  Zip::File.open(epub_file) do |file|
    opf_file_list = file.glob(File.join('**','*.opf'))
    if opf_file_list.count == 0
      puts "Error: OPF file not found for project #{File.basename(project_dir)}"
      next
    end
    puts "Warning: found multiple OPF files. Using first." if opf_file_list.count > 1

    opf_file_list.each do |opf_file|
      # Parse the epub OPF to find the path to cover image.
      parser.parse(opf_file.get_input_stream.read)
    end
    opf_info = opf_proc.opf_info

    cover_href = opf_info.args['cover_href']
    cover_file_list = file.glob(File.join('**', cover_href))
    cover_file = cover_file_list.count == 0 ? nil : cover_file_list.first

    isbn = opf_info.args['dc:identifier'] + " (ebook)"
    csv_file = File.expand_path('metadata.csv', project_dir)
    CSV.open(
            csv_file,
            "w",
            :write_headers=> true,
            :headers => [ "File Name", "Title", "Creator Display", "Publisher", "Pub Year", "ISBN(s)", "Representative Kind" ]
          ) do |csv|

      csv_row = [
        "*** row intentionally left blank ***",
          "",
          "",
          "",
          "",
          "",
          ""
      ]
      csv << csv_row

      if cover_file != nil
        csv_row = [
          File.basename(cover_file.name),
          "",
          "",
          "",
          "",
          "",
          "cover"
        ]
        csv << csv_row
      end

      csv_row = [
        File.basename(epub_file),
        File.basename(epub_file),
        "",
        "",
        "",
        "",
        "epub"
      ]
      csv << csv_row

      csv_row = [
        "://:MONOGRAPH://:",
        opf_info.args['dc:title'],
        opf_info.args['dc:creator'],
        opf_info.args['dc:publisher'],
        opf_info.args['dc:date'],
        isbn,
        ""
      ]
      csv << csv_row
    end

    bundle_file = File.expand_path(File.basename(epub_file, ".*") + "_bundle.zip", project_dir)
    if File.exists?(bundle_file)
      FileUtils.remove(bundle_file)
    end

    Zip::File.open(bundle_file, Zip::File::CREATE) do |zfile|
      zfile.add(File.basename(csv_file), csv_file)
      zfile.get_output_stream(File.basename(cover_file.name)) { |os| os.write cover_file.get_input_stream.read }
      zfile.add(File.basename(epub_file), epub_file)
    end
  end
end

