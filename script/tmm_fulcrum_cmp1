#!/usr/bin/env ruby
# frozen_string_literal: true

# Script compares 2 TMM to Fulcrum CSV files

require 'optparse'
require 'ostruct'
require 'os'

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require_relative File.join(root_dir, "lib", "logger")

script_logger = UMPTG::Logger.create(logger_fp: STDOUT)

# Process the script parameters.
options = OpenStruct.new
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} csv1_file csv2_file"
  opts.on_tail('-h', '--help', 'Print this help message') do
    script_logger.info(opts)
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 2
  script_logger.info(option_parser.help)
  return
end

# Process the command line parameters.
csv1_file = File.expand_path(ARGV[0])
csv2_file = File.expand_path(ARGV[1])
unless File.file?(csv1_file) and File.file?(csv2_file)
  script_logger.error("invalid path #{csv1_file},#{csv2_file}")
  exit 1
end

require 'csv'

CSV_READ_OPTIONS = { headers: true, encoding: 'bom|utf-8' }.freeze
#csv1 = CSV.read(csv1_file, encoding: 'bom|utf-8', headers:true, return_headers:false)
#puts csv1.count
csv2_fp = File.open(csv2_file, "rb", encoding:'bom|utf-16')
csv2_body = csv2_fp.read
puts csv2_body.encoding.name
csv2 = CSV.parse(csv2_body, headers:true,return_headers:false)
puts csv2.count
csv2_fp.close
#puts File.read(csv2_file).encoding.name
#csv2 = CSV.read(csv2_file, encoding: 'bom|utf-8', headers:true, return_headers:false)
#puts csv2.count
exit 0
#puts File.read(csv1_file).encoding.name
#puts File.read(csv2_file).encoding.name
#csv1_fp = File.open(csv1_file, "r:UTF-8")
=begin
csv1 = CSV.parse(
     #csv1_fp.read,
     csv1_body,
     headers: true,
     return_headers: false
    )
csv2_fp = File.open(csv2_file, "rb")
csv2 = CSV.parse(
     csv2_fp.read,
     headers: true,
     return_headers: false
    )
=end
csv1_lines = csv1_fp.readlines
csv2_lines = csv2_fp.readlines
puts csv1_lines[1]
puts csv2_lines[1]
exit 0
for i in 0..(csv1_lines.count-1) do
  line_num = i+1
  l1 = csv1_lines[i]
  if l1.nil? or l1.strip.empty?
    puts "#{line_num} l1"
    next
  end
  l2 = csv2_lines[i]
  if l2.nil? or l2.strip.empty?
    puts "#{line_num} l2"
    next
  end

  if l1 == l2
    puts line_num
  end
end

exit 0
diff1_rows = []
diff2_rows = []
diff_row = []
for i in 0..csv1.count do
  unless csv1[i].to_s == csv2[i].to_s
    diff1_rows << csv1[i]
    diff2_rows << csv2[i]
    diff_row << (i+2)
  end
end
puts "diff_cnt:#{diff1_rows.count}"
for i in 0..diff1_rows.count-1 do
  row1 = diff1_rows[i]
  row2 = diff2_rows[i]
  row1.each do |key,val1|
    next unless key=="Title"

    val2 = row2[key]
    unless val1 == val2
      puts "#{i},#{diff_row[i]},#{key}:len:#{val1.length},#{val2.length}"
      #puts val1
      #puts val2
      #exit 0
    end
  end
end

