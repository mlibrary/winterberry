#!/usr/bin/env ruby
# frozen_string_literal: true

# Script operates on a monograph directory found the Fulcrum
# shared drive.
#
# Review specified monograph for Fulcrum compliance

require 'optparse'
require 'ostruct'
require 'os'

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require_relative File.join(root_dir, "lib", "fulcrum")

# Process the script parameters.
options = OpenStruct.new
options.publisher_dir = UMPTG::Fulcrum::Monograph.DEFAULT_PUBLISHER_DIR
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-d <publisher_dir>] [-f production|preview|staging] [-n] <monograph_id> [<monograph_id>...]"
  opts.on('-d', '--publisher_directory [DIRECTORY]', 'Publisher site directory') do |publisher_dir|
    options.publisher_dir = publisher_dir
  end
  opts.on('-f', '--fulcrum_host [production|preview|staging]', 'Fulcrum environment') do |fulcrum_host|
    options.fulcrum_host = fulcrum_host
  end
  opts.on('-n', '--normalize', 'Normalize EPUB') do |normalize|
    options.normalize = true
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    puts opts
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  puts option_parser.help
  return
end

# Process the command line parameters.
monograph_id_list = ARGV

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require 'fileutils'

require_relative File.join(root_dir, "lib", "review_new")

script_logger = UMPTG::MLogger.create(logger_fp: STDOUT)
script_logger.formatter = proc do |severity, datetime, progname, msg|
  "#{severity}: #{msg}\n"
end

monograph_id_list.each do |monograph_id|
  script_logger.info("*" * 10 + " #{monograph_id} " + "*" * 10)

  monograph = UMPTG::Fulcrum::Monograph.new(
              publisher_dir: options.publisher_dir,
              fulcrum_host: options.fulcrum_host,
              monograph_id: monograph_id
          )
  unless Dir.exists?(monograph.monograph_dir)
    script_logger.error("invalid monograph directory #{monograph.monograph_dir}.")
    next
  end

  review_dir = File.join(monograph.monograph_dir, "review")
  FileUtils.mkdir_p review_dir

  monograph_logger = UMPTG::MLogger.create(
              logger_file: File.join(review_dir, monograph_id + "_review.log")
           )

  epub_file = monograph.epub_file
  if epub_file.nil?
    monograph_logger.error("no EPUB file for id #{monograph_id}")
    next
  end

  # Process the epub and generate the image information.
  epub_reviewer = UMPTG::Review::EPUBReviewer.new(
        epub_file: epub_file,
        logger: monograph_logger
      )
  epub_reviewer.review(
        normalize: options.normalize,
        review_options: {
            package: true,
            link: false,
            list: false,
            resources: true,
            table: true
          }
      )

  if epub_reviewer.epub_modified
    epub_normalized_file = File.join(review_dir, File.basename(epub_file, ".*") + "_normal.epub")
    monograph_logger.info("Saving normalized EPUB \"#{File.basename(epub_normalized_file)}.")
    epub_reviewer.epub.save(epub_file: epub_normalized_file)
  end

  epub_reviewer.resource_path_list.each do |entry_name,path_list|
    path_list.each do |path|
      if monograph.manifest.nil?
        resource_file_list = Dir.glob(File.join(monograph.resources_dir, File.basename(path, ".*") + ".*"))
        case
        when resource_file_list.count == 1
          monograph_logger.info("#{entry_name}: resource file found for reference \"#{File.basename(path)}\".")
        when resource_file_list.count > 1
          monograph_logger.warn("#{entry_name}: found mulitple resource files for reference \"#{File.basename(path)}\".")
        else
          monograph_logger.error("#{entry_name}: resource file not found for reference \"#{File.basename(path)}\".")
        end
      else
        fileset = monograph.manifest.fileset(path)
        resource_file_list = fileset["noid"].empty? ? [] : [ fileset["resource_name"] ]
        case
        when resource_file_list.count == 1
          monograph_logger.info("#{entry_name}: resource file found for reference \"#{File.basename(path)}\".")
        else
          monograph_logger.warn("#{entry_name}: resource file not found for reference \"#{File.basename(path)}\".")
        end
      end
    end
  end

  monograph_logger.close
end
