#!/usr/bin/env ruby
# frozen_string_literal: true

# Script takes a list of EPUBs, determines the list of
# CSS stylesheets and outputs info about each, and
# possibly replaces stylesheets

require 'optparse'
require 'ostruct'
require 'os'

# Determine the root directory of the code base.
script_dir = File.expand_path(File.dirname(__FILE__))
root_dir = File.dirname(script_dir)

require_relative File.join(root_dir, "lib", "logger")

script_logger = UMPTG::Logger.create(logger_fp: STDOUT)

# Process the script parameters.
options = OpenStruct.new
options.css_file_list = []
options.manifest_item_file_list = []
options.force_update = false
options.license = nil
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [-f] [-c css_file] [-l license] [-m manifest_item] epub_file [epub_file...]"
  opts.on('-c', '--css [css_file]', 'CSS replacement') do |css_file|
    options.css_file_list << css_file
  end
  opts.on('-l', '--license [license]', 'License') do |license|
    options.license = license
  end
  opts.on('-m', '--manifest_item item_file', 'Manifest item') do |item_file|
    options.manifest_item_file_list << item_file
  end
  opts.on('-f', '--css [css_file]', 'CSS replacement') do |css_file|
    options.force_update = true
  end
  opts.on_tail('-h', '--help', 'Print this help message') do
    script_logger.info(opts)
    exit 0
  end
end
option_parser.parse!(ARGV)
if ARGV.count < 1
  script_logger.info(option_parser.help)
  return
end
epub_file_list = ARGV

require_relative File.join(root_dir, 'lib', 'review')

badge_file = nil
unless options.license.nil?
  # Determine is license badge is available
  badge_file = Dir.glob(File.join(root_dir, "lib", "license", "cc_badges", options.license + ".*")).first
  if badge_file.nil?
    script_logger.error("CC badge #{options.license} is not found.")
  else
    script_logger.info("CC badge #{badge_file} found.")
    options.manifest_item_file_list << badge_file
  end
end

epub_updater = UMPTG::Review::EPUBUpdater.new(
      logger: script_logger
      )

# Travese the list of EPUB files to update.
epub_file_list.each do |epub_file|
  epub_file = File.expand_path(epub_file)
  unless File.exist?(epub_file)
    script_logger.error("invalid EPUB file path #{epub_file}.")
    next
  end
  script_logger.info("*** processing #{File.basename(epub_file)} ***")
  STDOUT.flush

  epub = UMPTG::EPUB::Archive.new(epub_file: epub_file)

  unless options.css_file_list.empty?
    epub_updater.update_css(
        epub: epub,
        css_file_list: options.css_file_list,
        css_force_update: options.force_update,
        )
  end

  options.manifest_item_file_list.each do |manifest_item_file|
    manifest_item_file = File.expand_path(manifest_item_file)
    puts manifest_item_file

    epub_updater.add_item(
        epub: epub,
        item_file: manifest_item_file,
        #spine_loc: 2
        )
  end

  unless badge_file.nil?
    # Process the epub and generate the image information.
    epub_reviewer = UMPTG::Review::EPUBReviewer.new(
          epub: epub,
          logger: script_logger
        )

    epub_reviewer.review(
          review_options: { add_license: true },
          license_file: badge_file,
          normalize: true
        )
    action_map = epub_reviewer.action_map
  end

  if epub.modified
    # EPUB updated. Save it to a new file.
    new_epub_file = File.join(File.dirname(epub_file), File.basename(epub_file, ".*") + "_replace" + File.extname(epub_file))
    script_logger.info("EPUB updated. Writing new EPUB file #{File.basename(new_epub_file)}")
    epub.save(epub_file: new_epub_file)
  else
    # No EPUB updates.
    script_logger.info("no updates for EPUB file #{File.basename(epub_file)}")
  end

  script_logger.info()
  STDOUT.flush
end
